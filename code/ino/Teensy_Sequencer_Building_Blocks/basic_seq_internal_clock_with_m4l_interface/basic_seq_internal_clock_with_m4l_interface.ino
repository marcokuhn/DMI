/* DMI coursew, WS 2020-21 @ SRH
   marco.kuhn@srh.de

  -> INTERNAL CLOCK with METRO
  -> M4L Interface = teensy_seq_ctrl_interface_internal_clock.amxd
   
    this is based on the code from Otem Rellik:
    https://github.com/otem/mr_touchy_teensy_polysynth_drummachine
 
*/
#include <Metro.h>

// ************************* START – GENERATED BY AUDIO DESIGN TOOL  
#include <Audio.h>
#include <Wire.h>
#include <SPI.h>
#include <SD.h>
#include <SerialFlash.h>

// GUItool: begin automatically generated code
AudioSynthSimpleDrum     drum1;          //xy=892.2000122070312,364.2000045776367
AudioOutputI2S           i2s1;           //xy=1077.199951171875,364.2000045776367
AudioConnection          patchCord1(drum1, 0, i2s1, 0);
AudioConnection          patchCord2(drum1, 0, i2s1, 1);
AudioControlSGTL5000     sgtl5000_1;     //xy=904.199951171875,452.20003509521484
// GUItool: end automatically generated code


// ************************* END – GENERATED BY AUDIO DESIGN TOOL 

// Metro – makes it easy to schedule events to occur at regular intervals
// https://www.pjrc.com/teensy/td_libs_Metro.html
Metro metro = Metro(100);
int kickSteps[16] = {1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0};

bool seqPlay = true;
int seqStep = 0;
int prevSeqStep = 15;

void setup() {
  AudioMemory(20);
  sgtl5000_1.enable();
  sgtl5000_1.volume(0.8);
  
  drum1.frequency(80);
  drum1.length(300);

  usbMIDI.setHandleControlChange(getControlChangeMsg);
}

void loop() {
   // The handler functions are called when usbMIDI reads data.  They
  // will not be called automatically.  You must call usbMIDI.read()
  // regularly from loop() for usbMIDI to actually read incoming
  // data and run the handler functions as messages arrive.
  usbMIDI.read();
  
  //DRUMS
  if (seqPlay) {
    if (metro.check() == 1) {
      seqStep++;
      // send stepIndex to Max for Live CTRL Interface
      usbMIDI.sendControlChange(30, seqStep, 1);
    }
    if (seqStep >= 16) {
      seqStep = 0;
    }
    //Play da Drums
    if (abs(seqStep - prevSeqStep) > 0) {
        
      if (kickSteps[seqStep]) {
        drum1.noteOn();
      }
    }
    prevSeqStep = seqStep;
  }
}


void getControlChangeMsg(byte channel, byte control, byte value) {
   
   // set Steps with Max for Liev Interface via MIDI-CC
   if(control >= 50 && control <= 65){
      int stepIndex = control - 50;
      kickSteps[stepIndex] = value;        
  }  
}

// http://www.sengpielaudio.com/calculator-bpmtempotime.htm
float convertBPMtoMS(int bpm){
    float ms = (float) 60000 / bpm;
    return ms;
}
